use base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};
use ed25519_dalek::{Signature, Signer, SigningKey, Verifier, VerifyingKey};
use rand::rngs::OsRng;
use sha2::Sha256;
use std::fs;
use std::path::Path;
use std::process::Command;

// --- PUBLIC CONSTANTS ---
// TODO: Replace this with the ACTUAL Public Key generated by the Admin Tool later.
// For now, we put a placeholder. The verified WILL fail until this is updated.
pub const PUBLIC_KEY_B64: &str = "uu3BvCGjUdn+w9KRMiOPrEforF+tDZ72WQc5D7A1Fmk=";

pub fn get_hardware_id() -> String {
    // 1. Try WMIC (Standard)
    if let Ok(output) = Command::new("wmic")
        .args(&["csproduct", "get", "uuid"])
        .output()
    {
        let raw = String::from_utf8_lossy(&output.stdout);
        // Parse: "UUID\nXXXXXXXX-XXXX-..."
        let parts: Vec<&str> = raw.lines().collect();
        for part in parts {
            let trimmed = part.trim();
            if !trimmed.is_empty() && trimmed != "UUID" {
                return trimmed.to_string();
            }
        }
    }

    // Fallback: Random (Should not happen on real windows)
    "UNKNOWN-HWID-0000".to_string()
}

pub fn verify_signature(hwid: &str, license_key: &str) -> bool {
    // 1. Developer Bypass: Check for .antigravity_master file
    if Path::new(".antigravity_master").exists() {
        return true;
    }

    // 2. Decode Public Key
    let public_bytes = match BASE64.decode(PUBLIC_KEY_B64) {
        Ok(b) => b,
        Err(_) => return false,
    };

    let verifying_key =
        match VerifyingKey::from_bytes(&public_bytes.try_into().unwrap_or([0u8; 32])) {
            Ok(k) => k,
            Err(_) => return false,
        };

    // 3. Decode Signature (License Key)
    let signature_bytes = match BASE64.decode(license_key) {
        Ok(b) => b,
        Err(_) => return false,
    };

    let signature_arr: [u8; 64] = match signature_bytes.try_into() {
        Ok(a) => a,
        Err(_) => return false,
    };

    let signature = Signature::from_bytes(&signature_arr);

    // 4. Verify
    verifying_key.verify(hwid.as_bytes(), &signature).is_ok()
}

// --- ADMIN TOOL (Run Once to Generate Keys) ---
pub fn data_generate_admin_keys() -> (String, String) {
    use rand::RngCore;
    let mut csprng = OsRng;
    let mut bytes = [0u8; 32];
    csprng.fill_bytes(&mut bytes);

    let signing_key = SigningKey::from_bytes(&bytes);
    let verifying_key = VerifyingKey::from(&signing_key);

    let priv_b64 = BASE64.encode(signing_key.to_bytes());
    let pub_b64 = BASE64.encode(verifying_key.to_bytes());

    (priv_b64, pub_b64)
}

// --- ADMIN TOOL (Sign a User's HWID) ---
pub fn admin_sign_hwid(private_key_b64: &str, user_hwid: &str) -> Result<String, String> {
    let priv_bytes = BASE64
        .decode(private_key_b64)
        .map_err(|_| "Invalid Key Base64")?;
    let signing_key =
        SigningKey::from_bytes(&priv_bytes.try_into().map_err(|_| "Invalid Key Len")?);

    let signature = signing_key.sign(user_hwid.as_bytes());
    Ok(BASE64.encode(signature.to_bytes()))
}
